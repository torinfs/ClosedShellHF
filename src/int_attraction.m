function [ Vne ] = int_attraction( basis )
%Takes a 1xM vector of all basis functions and returns the
%   electron-nuclear attraction matrix.
%
%   Inputs:
%       basis --    1xM basis vector generated by makebasis()
%
%   Outputs:
%       Vne --      MxM matrix of electron-nuclear attraction integral
%                   results.
%

M = numel(basis);
Vne = zeros(M);

%Get the unique positions of the atoms
[C, iA, ~] = unique(vertcat(basis(:).A), 'rows', 'stable');
for Znum = 1:numel(iA)
    Zc(Znum) = basis(iA(Znum)).atom;
end
%Loop through basis sets, but only upper triangle
for u = 1:M
    for v = u:M
        %Loop through atoms
        for i = 1:size(C,1)
            c_cart = C(i, :);
            
            uvC_int = 0;
            %Loop through basis sets
            for k = 1:numel(basis(u).d)
                for l = 1:numel(basis(v).d)
                    integral = struct(...
                        'A',        basis(u).A,...
                        'B',        basis(v).A,...
                        'p',        basis(u).alpha(k) + basis(v).alpha(l),...
                        'P',        (basis(u).alpha(k)*basis(u).A +...
                                    basis(v).alpha(l)*basis(v).A)/...
                                    (basis(u).alpha(k) + basis(v).alpha(l)),...
                        'a',        basis(u).a,...
                        'b',        basis(v).a,...
                        'C',        c_cart,...
                        'prefactor',1,...
                        'm',        0);
                    
                    abC_reduced = VRR_b(VRR_a(integral));
                    Kab = exp(-((basis(u).alpha(k)*basis(v).alpha(l))/...
                        (basis(u).alpha(k) + basis(v).alpha(l)))*...
                        (basis(u).A - basis(v).A)*(basis(u).A-basis(v).A)');
                    
                    abC_int = eval_int(abC_reduced, Kab);
                    
                    uvC_int = uvC_int + basis(u).d(k)*basis(v).d(l)*...
                        basis(u).N(k)*basis(v).N(l)*abC_int;
                end
            end
            Vne(u, v) = Vne(u, v) + Zc(i)*uvC_int;
        end
    end
end
Vne = -(Vne + triu(Vne, 1)');

end

function int_array = VRR_a(integral)
    switch sum(integral.a)
        case 0
            int_array = integral;
        case 1
            w = find(integral.a == 1);
            
            %First term (Guaranteed non-zero)
            int_array(1) = integral;
            int_array(1).prefactor = (integral.P(w) - integral.A(w))*...
                                     integral.prefactor;
            int_array(1).a(w) = integral.a(w)-1;
            
            %Second term (Guaranteed non-zero)
            int_array(2) = integral;
            int_array(2).prefactor = (integral.C(w) - integral.P(w))*...
                                     integral.prefactor;
            int_array(2).a(w) = integral.a(w) - 1;
            int_array(2).m = integral.m + 1;
            
            %3rd and 4th terms = 0
            %5th and 6th terms depend on values of b(w)
            if integral.b(w) ~= 0
                int_array(3) = integral;
                int_array(3).prefactor = (integral.b(w)/(2*integral.p))*...
                                         integral.prefactor;
                int_array(3).a(w) = integral.a(w) - 1;
                int_array(3).b(w) = integral.b(w) - 1;
                
                int_array(4) = int_array(3);
                int_array(4).prefactor = -int_array(3).prefactor;
                int_array(4).m = integral.m + 1;
            end
        case 2
            w = find(integral.a == 2);
            
            if ~(isempty(w))
                %First term (Guaranteed non-zero)
                temp_int = integral;
                temp_int.prefactor = (integral.P(w) - integral.A(w))*...
                                    integral.prefactor;
                temp_int.a(w) = integral.a(w)-1;
                %Because a(w) != 0, do it again
                int_array = VRR_a(temp_int);

                %Second term (Guaranteed non-zero)
                temp_int = integral;
                temp_int.prefactor = (integral.C(w) - integral.P(w))*...
                                    integral.prefactor;
                temp_int.a(w) = integral.a(w) - 1;
                temp_int.m = integral.m + 1;
                %Because a(w) != 0, do it again
                int_array = [int_array, VRR_a(temp_int)];
                
                %Third term, a(w) == 0 at the end of this
                temp_int = integral;
                temp_int.prefactor = ((integral.a(w) - 1)/(2*integral.p))*...
                                        integral.prefactor;
                temp_int.a(w) = integral.a(w) - 2;
                int_array = [int_array temp_int];
                
                %Fourth term, a(w) == 0 at the end of this
                temp_int = int_array(3);
                temp_int.prefactor = -int_array(end).prefactor;
                temp_int.m = integral.m + 1;
                int_array = [int_array, temp_int];
                
                %Fifth and sixth terms depend on values of b(w)
                if integral.b(w) ~= 0
                    temp_int5 = integral;
                    temp_int5.prefactor = (integral.b(w)/(2*integral.p))*...
                                            integral.prefactor;
                    temp_int5.a(w) = integral.a(w) - 1;
                    temp_int5.b(w) = integral.b(w) - 1;
                    %a(w) != 0
                    int_array = [int_array, VRR_a(temp_int5)];

                    temp_int = temp_int5;
                    temp_int.prefactor = -temp_int5.prefactor;
                    temp_int.m = integral.m + 1;
                    %a(w) != 0
                    int_array = [int_array, VRR_a(temp_int)];
                end
                
            %If the D orbital isn't quadratic in one coordinate, it's
            %linear in two.
            else
                w = find(integral.a == 1);
                int_array = integral;
                for i = 1:2
                    %First term (Guaranteed non-zero)
                    if(~(numel(int_array) == 1))
                        int_array(end+1) = integral; %#ok<*AGROW>
                    end
                    int_array(end).prefactor = (integral.P(w(i)) -...
                           integral.B(w(i)))*integral.prefactor;
                    int_array(end).a(w(i)) = integral.a(w(i))-1;

                    %Second term (Guaranteed non-zero)
                    int_array(end+1) = integral;
                    int_array(end).prefactor = (integral.C(w(i)) -...
                        integral.P(w(i)))*integral.prefactor;
                    int_array(end).a(w(i)) = integral.a(w(i)) - 1;
                    int_array(end).m = integral.m + 1;

                    %3rd and 4th terms = 0
                    %5th and 6th terms depend on values of b(w)
                    if integral.b(w(i)) ~= 0
                        int_array(end+1) = integral;
                        int_array(end).prefactor = (integral.b(w(i))/...
                            (2*integral.p))*integral.prefactor;
                        int_array(end).a(w(i)) = integral.a(w(i)) - 1;
                        int_array(end).b(w(i)) = integral.b(w(i)) - 1;

                        int_array(end+1) = int_array(end);
                        int_array(end).prefactor = -int_array(end-1).prefactor;
                        int_array(end).m = integral.m + 1;
                    end
                end
            end   
    end
end



function int_array = VRR_b(integrals)
    int_array = [];
    for int_num = 1:numel(integrals)
        integral = integrals(int_num);
        switch sum(integral.b)
            case 0
                temp_array = integral;
            case 1
                w = find(integral.b == 1);

                %First term (Guaranteed non-zero)
                temp_array(1) = integral;
                temp_array(1).prefactor = (integral.P(w) - integral.B(w))*...
                                         integral.prefactor;
                temp_array(1).b(w) = integral.b(w)-1;

                %Second term (Guaranteed non-zero)
                temp_array(2) = integral;
                temp_array(2).prefactor = (integral.C(w) - integral.P(w))*...
                                         integral.prefactor;
                temp_array(2).b(w) = integral.b(w) - 1;
                temp_array(2).m = integral.m + 1;

                %3rd-6th terms == 0
            case 2
                w = find(integral.b == 2);

                if ~(isempty(w))
                    %First term (Guaranteed non-zero)
                    temp_int = integral;
                    temp_int.prefactor = (integral.P(w) - integral.B(w))*...
                                        integral.prefactor;
                    temp_int.b(w) = integral.b(w)-1;
                    %Because b(w) != 0, do it again
                    temp_array = VRR_b(temp_int);

                    %Second term (Guaranteed non-zero)
                    temp_int = integral;
                    temp_int.prefactor = (integral.C(w) - integral.P(w))*...
                                        integral.prefactor;
                    temp_int.b(w) = integral.b(w) - 1;
                    temp_int.m = integral.m + 1;
                    %Because b(w) != 0, do it again
                    temp_array = [temp_array, VRR_b(temp_int)];

                    %Third term, a(w) == 0 at the end of this
                    temp_int = integral;
                    temp_int.prefactor = ((integral.b(w) - 1)/(2*integral.p))*...
                                            integral.prefactor;
                    temp_int.b(w) = integral.b(w) - 2;
                    temp_array = [temp_array, temp_int];

                    %Fourth term, a(w) == 0 at the end of this
                    temp_int = temp_array(3);
                    temp_int.prefactor = -temp_array(3).prefactor;
                    temp_int.m = integral.m + 1;
                    temp_array = [temp_array, temp_int];

                    %Fifth and sixth terms == 0

                %If the D orbital isn't quadratic in one coordinate, it's
                %linear in two.
                else
                    w = find(integral.b == 1);
                    temp_array = integral;
                    for i = 1:2
                        %First term (Guaranteed non-zero)
                        if(~(numel(temp_array) == 1))
                            temp_array(end+1) = integral;
                        end
                        temp_array(end).prefactor = (integral.P(w(i)) -...
                               integral.B(w(i)))*integral.prefactor;
                        temp_array(end).b(w(i)) = integral.b(w(i))-1;

                        %Second term (Guaranteed non-zero)
                        temp_array(end+1) = integral;
                        temp_array(end).prefactor = (integral.C(w(i)) -...
                            integral.P(w(i)))*integral.prefactor;
                        temp_array(end).b(w(i)) = integral.b(w(i)) - 1;
                        temp_array(end).m = integral.m + 1;

                        %3rd - 6th terms == 0
                    end
                end 
        end
        int_array = [int_array, temp_array];
    end
end

function abC_int = eval_int(integrals, Kab)
    abC_int = 0;
    for i = 1:numel(integrals)
        integral = integrals(i);
        T = integral.p*(integral.P - integral.C)*(integral.P-integral.C)';
        s_int = 2*pi/integral.p*Kab*Boys(T, integral.m);
        abC_int = integral.prefactor*s_int + abC_int;
    end
end

%NOTE: I checked, this function gives the correct results for m=0,1. m = 2
%   not yet checked
function y = Boys(T, m)
    %gamma(x) = integral from 0 to inf of t^(x-1) exp(-t) dt
    
    %gammainc(x,a) = 1 ./ gamma(a) .* integral from 0 to x of t^(a-1) exp(-t) dt
    %Therefore, lower gamma should be gammainc(x,a).*gamma(a)
    
    %gammainc(x, a, 'upper') = 1 - gammainc(x, a)
    %Therefore, upper gamma should be gammainc(x, a, 'upper').*gamma(a)
    
    %We also need to set some threshold to switch from the Boys function to
    %the limiting behavior
    if T < 1e-8
        y = 1/(2*m + 1);
    else
        y = (gammainc(T, m+0.5)*gamma(m+0.5))/(2*T^(m+0.5));
    end
end
